# TEE MultiClient Proof

This document details the architecture for achieving atomic withdrawals using validity proofs generated by a diverse set of TEE clients.

## Architecture

![tee_multiclient](/img/tee-multi-prover/tee_multiclient.png)

1. When the TDX Execution Engine (op-geth/op-reth) starts up, it registers itself with the `ProverRegistry`. During registration, it generates an attestation report that includes the client type and submits this report to the `ProverRegistry`. The `ProverRegistry` then extracts information from the attestation report, specifically the public key, teeType, and elType(execution layer type), and uses the `AttestationVerifier` to verify its validity. If everything is successful, it stores the prover’s information in storage.
2. The L2 Output Submitter (op-proposer) scans l2 blocks to retrieve withdrawal parameters.
3. The L2 Output Submitter fetches execution proofs for a specific block from multiple TEE execution clients. It maintains a list of registered provers and knows how many proof types are required for a valid fast atomic withdrawal.
4. The L2 Output Submitter aggregates these proofs and calls the `atomicWithdrawal` function in `DisputeGameFactory`, providing the aggregated proofs as input. 
5. `DisputeGameFactory` sends the proofs to the `ProverRegistry` for verification. Within the `ProverRegistry`, the public key of the prover is extracted from the proof to check if it’s a registered prover. Because the execution layer type (elType) and TEE type can be determined from the registered prover information, the system can validate proofs originating from multiple types simultaneously.
